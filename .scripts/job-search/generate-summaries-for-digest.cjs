#!/usr/bin/env node
/**
 * Generate summaries for jobs in digest file that have job descriptions but no summary yet.
 * Uses MCP job-digest server to parse LinkedIn pages and prepare data for summary generation.
 * 
 * Usage:
 *   node generate-summaries-for-digest.cjs [digest-file.md]
 * 
 * This script:
 * 1. Reads digest file
 * 2. Finds jobs without summaries
 * 3. Parses job descriptions from LinkedIn
 * 4. Prepares data for summary generation (summary is generated by Claude in Cursor)
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const VAULT = process.env.VAULT_PATH || path.resolve(__dirname, '../..');
const JOB_SEARCH_DIR = path.join(VAULT, '00-Inbox', 'Job_Search');

/**
 * Parse digest file and extract jobs
 */
function parseDigest(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const jobs = [];
  
  // Match job entries: - [ ] [Title · Company · Type](URL)
  const jobPattern = /- \[ \] \[([^\]]+)\]\(([^\)]+)\)/g;
  let match;
  let lastIndex = 0;
  
  while ((match = jobPattern.exec(content)) !== null) {
    const titleLine = match[1];
    const url = match[2];
    const lineIndex = match.index;
    
    const parts = titleLine.split('·').map(p => p.trim());
    const title = parts[0] || '';
    const company = parts[1] || '';
    const workType = parts[2] || '';
    
    // Check if summary already exists (look for content after URL line)
    const nextJobMatch = content.substring(lineIndex).match(/- \[ \] \[/);
    const jobContentEnd = nextJobMatch ? lineIndex + nextJobMatch.index : content.length;
    const jobContent = content.substring(lineIndex, jobContentEnd);
    
    const hasSummary = jobContent.includes('**Suggested questions:**') || 
                      (jobContent.split('\n').filter(l => l.trim()).length > 2 && 
                       !jobContent.includes('---'));
    
    jobs.push({
      title,
      company,
      workType,
      url,
      hasSummary,
      lineIndex,
      contentEnd: jobContentEnd,
      content: jobContent
    });
  }
  
  return { jobs, content };
}

/**
 * Call MCP tool to parse LinkedIn job and prepare summary data
 */
async function parseJobAndPrepareSummary(jobUrl) {
  const pythonScript = `
import sys
import json
import asyncio
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent / 'core' / 'mcp'))

from job_digest_server import parse_linkedin_job

async def main():
    job_url = sys.argv[1]
    try:
        result = await parse_linkedin_job(job_url)
        print(json.dumps(result))
    except Exception as e:
        print(json.dumps({"error": str(e)}))

asyncio.run(main())
`;
  
  try {
    const result = execSync(`python3 -c ${JSON.stringify(pythonScript)} ${JSON.stringify(jobUrl)}`, {
      encoding: 'utf-8',
      cwd: VAULT,
      env: { ...process.env, PYTHONPATH: path.join(VAULT, 'core', 'mcp') },
      maxBuffer: 10 * 1024 * 1024
    });
    
    return JSON.parse(result);
  } catch (error) {
    return { error: error.message };
  }
}

/**
 * Generate summary using Claude (via /job-summary skill logic)
 * This prepares the data - actual generation happens in Cursor context
 */
function prepareSummaryData(parsedData) {
  if ('error' in parsedData) {
    return null;
  }
  
  return {
    job_type: parsedData.get('job_type', 'ai'),
    cv_path: parsedData.get('cv_path', ''),
    job_description: parsedData.get('job_description', ''),
    job_title: parsedData.get('job_title', ''),
    company: parsedData.get('company', ''),
    keywords: parsedData.get('keywords', {}),
    note: 'Use /job-summary skill with job_description to generate summary, or generate directly in Cursor using this data.'
  };
}

/**
 * Main function
 */
async function main() {
  const args = process.argv.slice(2);
  let digestFile = args[0];
  
  // If no file specified, find latest digest
  if (!digestFile) {
    const files = fs.readdirSync(JOB_SEARCH_DIR)
      .filter(f => f.startsWith('linkedin-jobs-') && f.endsWith('.md'))
      .sort()
      .reverse();
    
    if (files.length === 0) {
      console.error('No digest files found in', JOB_SEARCH_DIR);
      process.exit(1);
    }
    
    digestFile = files[0];
    console.log(`Using latest digest: ${digestFile}`);
  }
  
  const digestPath = path.isAbsolute(digestFile) 
    ? digestFile 
    : path.join(JOB_SEARCH_DIR, digestFile);
  
  if (!fs.existsSync(digestPath)) {
    console.error(`Digest file not found: ${digestPath}`);
    process.exit(1);
  }
  
  const { jobs, content } = parseDigest(digestPath);
  console.log(`Found ${jobs.length} jobs in digest`);
  
  const jobsWithoutSummary = jobs.filter(j => !j.hasSummary);
  console.log(`${jobsWithoutSummary.length} jobs without summary`);
  
  if (jobsWithoutSummary.length === 0) {
    console.log('All jobs already have summaries');
    return;
  }
  
  console.log('\nParsing job descriptions and preparing summary data...');
  console.log('Note: Summary generation requires Claude in Cursor context.');
  console.log('Use /job-summary skill with job descriptions or generate directly in Cursor.\n');
  
  // For now, just show which jobs need summaries
  // Actual summary generation happens in Cursor via /job-summary skill
  jobsWithoutSummary.forEach((job, index) => {
    console.log(`${index + 1}. ${job.title} at ${job.company}`);
    console.log(`   URL: ${job.url}`);
    console.log(`   Use: /job-summary [paste job description from LinkedIn]\n`);
  });
  
  console.log('\nTo automatically parse job descriptions, use MCP tool: parse_linkedin_job');
  console.log('Then generate summaries using /job-summary skill in Cursor.');
}

if (require.main === module) {
  main().catch(err => {
    console.error('Error:', err.message);
    process.exit(1);
  });
}

module.exports = { parseDigest, parseJobAndPrepareSummary };
